
/**
 * 生成fetch leetcode info的header，这里不使用cookies也可以拿到信息，因为不登录
 */
const generateHeader = (title) => {
    //generated by postman.app
    const myHeaders = new Headers();
    myHeaders.append("Connection", "keep-alive");
    myHeaders.append("Origin", "https://leetcode.cn");
    myHeaders.append("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36");
    myHeaders.append("X-CSRFToken", "hAENke6ObibMXfb2hvOWxPKIDz1Vo1UlEFlH9IWctL5wS7wXBBWSbbhZ2c3YMB1T");
    myHeaders.append("accept", "*/*");
    myHeaders.append("accept-language", "zh-CN");
    myHeaders.append("content-type", "application/json");
    myHeaders.append("sec-ch-ua", "\"Chromium\";v=\"112\", \"Google Chrome\";v=\"112\", \"Not:A-Brand\";v=\"99\"");
    myHeaders.append("sec-ch-ua-mobile", "?0");
    myHeaders.append("x-definition-name", "question");
    myHeaders.append("x-operation-name", "questionData");
    myHeaders.append("x-timezone", "Asia/Shanghai");
    myHeaders.append("Access-Control-Allow-Origin", "*");
    myHeaders.append("host", "https://leetcode.cn/");
    const raw = JSON.stringify({ "operationName": "questionData", "variables": { "titleSlug": `${title}` }, "query": "query questionData($titleSlug: String!) {\n  question(titleSlug: $titleSlug) {\n    questionId\n    questionFrontendId\n    categoryTitle\n    boundTopicId\n    title\n    titleSlug\n    content\n    translatedTitle\n    translatedContent\n    isPaidOnly\n    difficulty\n    likes\n    dislikes\n    isLiked\n    similarQuestions\n    contributors {\n      username\n      profileUrl\n      avatarUrl\n      __typename\n    }\n    langToValidPlayground\n    topicTags {\n      name\n      slug\n      translatedName\n      __typename\n    }\n    companyTagStats\n    codeSnippets {\n      lang\n      langSlug\n      code\n      __typename\n    }\n    stats\n    hints\n    solution {\n      id\n      canSeeDetail\n      __typename\n    }\n    status\n    sampleTestCase\n    metaData\n    judgerAvailable\n    judgeType\n    mysqlSchemas\n    enableRunCode\n    envInfo\n    book {\n      id\n      bookName\n      pressName\n      source\n      shortDescription\n      fullDescription\n      bookImgUrl\n      pressImgUrl\n      productUrl\n      __typename\n    }\n    isSubscribed\n    isDailyQuestion\n    dailyRecordStatus\n    editorType\n    ugcQuestionId\n    style\n    exampleTestcases\n    jsonExampleTestcases\n    __typename\n  }\n}\n" });

    return {
        method: 'POST',
        headers: myHeaders,
        body: raw,
        redirect: 'follow'
    };
}
const baseURL = "https://leetcode.cn/problems/"
let info = {}



const fetchRatingData = async (title) => {
    const result = await fetch("https://zerotrac.github.io/leetcode_problem_rating/data.json", {
        "referrerPolicy": "strict-origin-when-cross-origin",
        "body": null,
        "method": "GET",
        "mode": "cors",
        "credentials": "omit"
    }).then(response => response.text())
        .catch(e => console.log(e));
    return JSON.parse(result).find(i => i.TitleSlug === title)
}

const fetchTagsAndHints = async (title) => {
    const requestOptions = generateHeader(title)
    // await chrome.cookies.getAll({ url: "https://leetcode.cn/problems/" }, (cookies) => {
    // }) 不拿cookies
    const result = await fetch("https://leetcode.cn/graphql/", { ...requestOptions })
        .then(resp => resp.text())
        .then(res => JSON.parse(res))
        .catch(error => console.log("cannot fetch"))
    return result
}

//TODO:是否为新版
const fetchIsBeta = async () => {
    const result = await fetch("https://leetcode.cn/graphql/noj-go", {
        "headers": {
            "accept": "*/*",
            "accept-language": "zh-CN,zh;q=0.9",
            "content-type": "application/json",
            "random-uuid": "a69f89fa-6e8d-667b-52db-0a9b187e37ba",
            "sec-ch-ua": "\"Chromium\";v=\"112\", \"Google Chrome\";v=\"112\", \"Not:A-Brand\";v=\"99\"",
            "sec-ch-ua-mobile": "?0",
            "sec-ch-ua-platform": "\"macOS\"",
            "sec-fetch-dest": "empty",
            "sec-fetch-mode": "cors",
            "sec-fetch-site": "same-origin",
        },
        "referrer": "https://leetcode.cn/problems/shortest-path-in-binary-matrix/",
        "referrerPolicy": "strict-origin-when-cross-origin",
        "body": "{\"operationName\":\"getBeta\",\"variables\":{},\"query\":\"query getBeta {\\n  userBetaStatusV2(participationType: NEW_QUESTION_DETAIL_PAGE) {\\n    inBeta\\n    hitBeta\\n    __typename\\n  }\\n}\\n\"}",
        "method": "POST",
        "mode": "cors",
        "credentials": "include"
    })
        .then(res => res.text())
        .catch(e => console.log(e))
    return JSON.parse(result);
}



//添加tabs监听器，在载入页面时获取题目与周赛名
chrome.tabs.onUpdated.addListener(async function myListener(tabId, changeInfo, tab) {
    if (tab.url.startsWith(baseURL)) {
        const title = tab.url.replace(baseURL, "").replace("/", "");
        if (!info[title]) {
            //避免重复fetch
            const leetcodeTagsAndHints = await fetchTagsAndHints(title) //{data:,qustion,}
            const weeklyContest = await fetchRatingData(title); //可以是undefined，表示没有周赛数据
            const isBeta = await fetchIsBeta();
            info = {
                ...info, [title]: {
                    leetcodeTagsAndHints,
                    weeklyContest,
                    isBeta
                }
            }
        }
        // chrome.tabs.onUpdated.removeListener(myListener)
    }
});



const fetchByTitle = async (title) => {
    const leetcodeTagsAndHints = await fetchTagsAndHints(title) //{data:,qustion,}
    const weeklyContest = await fetchRatingData(title); //可以是undefined，表示没有周赛数据
    const isBeta = await fetchIsBeta();
    const tmp = {
        ...info, [title]: {
            leetcodeTagsAndHints,
            weeklyContest,
            isBeta
        }
    }
    return tmp;
}


chrome.runtime.onMessage.addListener(async (msg, sender, sendResponse) => {
    switch (msg.action) {
        case "getData":
            if (!info[msg.title]) {
                await fetchByTitle(msg.title).then(info => sendResponse(info))
                return true;
            } else {
                sendResponse(info);
                return true;
            }

        default:
            return;
    }
})


